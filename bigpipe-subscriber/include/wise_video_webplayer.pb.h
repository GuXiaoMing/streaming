// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: wise_video_webplayer.proto

#ifndef PROTOBUF_wise_5fvideo_5fwebplayer_2eproto__INCLUDED
#define PROTOBUF_wise_5fvideo_5fwebplayer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace baidu {
namespace video {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_wise_5fvideo_5fwebplayer_2eproto();
void protobuf_AssignDesc_wise_5fvideo_5fwebplayer_2eproto();
void protobuf_ShutdownFile_wise_5fvideo_5fwebplayer_2eproto();

class Common;
class WiseVideoWebplayer;
class MetaData;

enum LanguageType {
  ZN_CH = 0,
  THAI = 1
};
bool LanguageType_IsValid(int value);
const LanguageType LanguageType_MIN = ZN_CH;
const LanguageType LanguageType_MAX = THAI;
const int LanguageType_ARRAYSIZE = LanguageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LanguageType_descriptor();
inline const ::std::string& LanguageType_Name(LanguageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LanguageType_descriptor(), value);
}
inline bool LanguageType_Parse(
    const ::std::string& name, LanguageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LanguageType>(
    LanguageType_descriptor(), name, value);
}
enum CodeType {
  CODE_TYPE_UNKNOWN = 0,
  UTF8 = 1,
  GBK = 2,
  GB18030 = 3
};
bool CodeType_IsValid(int value);
const CodeType CodeType_MIN = CODE_TYPE_UNKNOWN;
const CodeType CodeType_MAX = GB18030;
const int CodeType_ARRAYSIZE = CodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CodeType_descriptor();
inline const ::std::string& CodeType_Name(CodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CodeType_descriptor(), value);
}
inline bool CodeType_Parse(
    const ::std::string& name, CodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CodeType>(
    CodeType_descriptor(), name, value);
}
// ===================================================================

class Common : public ::google::protobuf::Message {
 public:
  Common();
  virtual ~Common();
  
  Common(const Common& from);
  
  inline Common& operator=(const Common& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Common& default_instance();
  
  void Swap(Common* other);
  
  // implements Message ----------------------------------------------
  
  Common* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Common& from);
  void MergeFrom(const Common& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string product_name = 1;
  inline bool has_product_name() const;
  inline void clear_product_name();
  static const int kProductNameFieldNumber = 1;
  inline const ::std::string& product_name() const;
  inline void set_product_name(const ::std::string& value);
  inline void set_product_name(const char* value);
  inline void set_product_name(const char* value, size_t size);
  inline ::std::string* mutable_product_name();
  inline ::std::string* release_product_name();
  
  // optional string module_name = 2;
  inline bool has_module_name() const;
  inline void clear_module_name();
  static const int kModuleNameFieldNumber = 2;
  inline const ::std::string& module_name() const;
  inline void set_module_name(const ::std::string& value);
  inline void set_module_name(const char* value);
  inline void set_module_name(const char* value, size_t size);
  inline ::std::string* mutable_module_name();
  inline ::std::string* release_module_name();
  
  // required string logid = 3;
  inline bool has_logid() const;
  inline void clear_logid();
  static const int kLogidFieldNumber = 3;
  inline const ::std::string& logid() const;
  inline void set_logid(const ::std::string& value);
  inline void set_logid(const char* value);
  inline void set_logid(const char* value, size_t size);
  inline ::std::string* mutable_logid();
  inline ::std::string* release_logid();
  
  // optional .baidu.video.LanguageType language = 4 [default = ZN_CH];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 4;
  inline baidu::video::LanguageType language() const;
  inline void set_language(baidu::video::LanguageType value);
  
  // optional .baidu.video.CodeType code_type = 5 [default = CODE_TYPE_UNKNOWN];
  inline bool has_code_type() const;
  inline void clear_code_type();
  static const int kCodeTypeFieldNumber = 5;
  inline baidu::video::CodeType code_type() const;
  inline void set_code_type(baidu::video::CodeType value);
  
  // required int64 timestamp = 10;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:baidu.video.Common)
 private:
  inline void set_has_product_name();
  inline void clear_has_product_name();
  inline void set_has_module_name();
  inline void clear_has_module_name();
  inline void set_has_logid();
  inline void clear_has_logid();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_code_type();
  inline void clear_has_code_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* product_name_;
  ::std::string* module_name_;
  ::std::string* logid_;
  int language_;
  int code_type_;
  ::google::protobuf::int64 timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_wise_5fvideo_5fwebplayer_2eproto();
  friend void protobuf_AssignDesc_wise_5fvideo_5fwebplayer_2eproto();
  friend void protobuf_ShutdownFile_wise_5fvideo_5fwebplayer_2eproto();
  
  void InitAsDefaultInstance();
  static Common* default_instance_;
};
// -------------------------------------------------------------------

class WiseVideoWebplayer : public ::google::protobuf::Message {
 public:
  WiseVideoWebplayer();
  virtual ~WiseVideoWebplayer();
  
  WiseVideoWebplayer(const WiseVideoWebplayer& from);
  
  inline WiseVideoWebplayer& operator=(const WiseVideoWebplayer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WiseVideoWebplayer& default_instance();
  
  void Swap(WiseVideoWebplayer* other);
  
  // implements Message ----------------------------------------------
  
  WiseVideoWebplayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WiseVideoWebplayer& from);
  void MergeFrom(const WiseVideoWebplayer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .baidu.video.MetaData metadata = 25;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 25;
  inline const ::baidu::video::MetaData& metadata() const;
  inline ::baidu::video::MetaData* mutable_metadata();
  inline ::baidu::video::MetaData* release_metadata();
  
  // optional string log_tag = 26;
  inline bool has_log_tag() const;
  inline void clear_log_tag();
  static const int kLogTagFieldNumber = 26;
  inline const ::std::string& log_tag() const;
  inline void set_log_tag(const ::std::string& value);
  inline void set_log_tag(const char* value);
  inline void set_log_tag(const char* value, size_t size);
  inline ::std::string* mutable_log_tag();
  inline ::std::string* release_log_tag();
  
  // required .baidu.video.Common common = 41;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 41;
  inline const ::baidu::video::Common& common() const;
  inline ::baidu::video::Common* mutable_common();
  inline ::baidu::video::Common* release_common();
  
  // optional string mac_address = 129;
  inline bool has_mac_address() const;
  inline void clear_mac_address();
  static const int kMacAddressFieldNumber = 129;
  inline const ::std::string& mac_address() const;
  inline void set_mac_address(const ::std::string& value);
  inline void set_mac_address(const char* value);
  inline void set_mac_address(const char* value, size_t size);
  inline ::std::string* mutable_mac_address();
  inline ::std::string* release_mac_address();
  
  // optional string flag = 130;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 130;
  inline const ::std::string& flag() const;
  inline void set_flag(const ::std::string& value);
  inline void set_flag(const char* value);
  inline void set_flag(const char* value, size_t size);
  inline ::std::string* mutable_flag();
  inline ::std::string* release_flag();
  
  // optional string all_data = 131;
  inline bool has_all_data() const;
  inline void clear_all_data();
  static const int kAllDataFieldNumber = 131;
  inline const ::std::string& all_data() const;
  inline void set_all_data(const ::std::string& value);
  inline void set_all_data(const char* value);
  inline void set_all_data(const char* value, size_t size);
  inline ::std::string* mutable_all_data();
  inline ::std::string* release_all_data();
  
  // optional string type = 132;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 132;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  
  // @@protoc_insertion_point(class_scope:baidu.video.WiseVideoWebplayer)
 private:
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_log_tag();
  inline void clear_has_log_tag();
  inline void set_has_common();
  inline void clear_has_common();
  inline void set_has_mac_address();
  inline void clear_has_mac_address();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_all_data();
  inline void clear_has_all_data();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::baidu::video::MetaData* metadata_;
  ::std::string* log_tag_;
  ::baidu::video::Common* common_;
  ::std::string* mac_address_;
  ::std::string* flag_;
  ::std::string* all_data_;
  ::std::string* type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_wise_5fvideo_5fwebplayer_2eproto();
  friend void protobuf_AssignDesc_wise_5fvideo_5fwebplayer_2eproto();
  friend void protobuf_ShutdownFile_wise_5fvideo_5fwebplayer_2eproto();
  
  void InitAsDefaultInstance();
  static WiseVideoWebplayer* default_instance_;
};
// -------------------------------------------------------------------

class MetaData : public ::google::protobuf::Message {
 public:
  MetaData();
  virtual ~MetaData();
  
  MetaData(const MetaData& from);
  
  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaData& default_instance();
  
  void Swap(MetaData* other);
  
  // implements Message ----------------------------------------------
  
  MetaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 log_module_id = 1 [default = 1526];
  inline bool has_log_module_id() const;
  inline void clear_log_module_id();
  static const int kLogModuleIdFieldNumber = 1;
  inline ::google::protobuf::int32 log_module_id() const;
  inline void set_log_module_id(::google::protobuf::int32 value);
  
  // optional string log_name = 2 [default = "wise_video_webplayer"];
  inline bool has_log_name() const;
  inline void clear_log_name();
  static const int kLogNameFieldNumber = 2;
  inline const ::std::string& log_name() const;
  inline void set_log_name(const ::std::string& value);
  inline void set_log_name(const char* value);
  inline void set_log_name(const char* value, size_t size);
  inline ::std::string* mutable_log_name();
  inline ::std::string* release_log_name();
  
  // optional string product_name = 3 [default = "video"];
  inline bool has_product_name() const;
  inline void clear_product_name();
  static const int kProductNameFieldNumber = 3;
  inline const ::std::string& product_name() const;
  inline void set_product_name(const ::std::string& value);
  inline void set_product_name(const char* value);
  inline void set_product_name(const char* value, size_t size);
  inline ::std::string* mutable_product_name();
  inline ::std::string* release_product_name();
  
  // @@protoc_insertion_point(class_scope:baidu.video.MetaData)
 private:
  inline void set_has_log_module_id();
  inline void clear_has_log_module_id();
  inline void set_has_log_name();
  inline void clear_has_log_name();
  inline void set_has_product_name();
  inline void clear_has_product_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* log_name_;
  static const ::std::string _default_log_name_;
  ::std::string* product_name_;
  static const ::std::string _default_product_name_;
  ::google::protobuf::int32 log_module_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_wise_5fvideo_5fwebplayer_2eproto();
  friend void protobuf_AssignDesc_wise_5fvideo_5fwebplayer_2eproto();
  friend void protobuf_ShutdownFile_wise_5fvideo_5fwebplayer_2eproto();
  
  void InitAsDefaultInstance();
  static MetaData* default_instance_;
};
// ===================================================================


// ===================================================================

// Common

// optional string product_name = 1;
inline bool Common::has_product_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Common::set_has_product_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Common::clear_has_product_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Common::clear_product_name() {
  if (product_name_ != &::google::protobuf::internal::kEmptyString) {
    product_name_->clear();
  }
  clear_has_product_name();
}
inline const ::std::string& Common::product_name() const {
  return *product_name_;
}
inline void Common::set_product_name(const ::std::string& value) {
  set_has_product_name();
  if (product_name_ == &::google::protobuf::internal::kEmptyString) {
    product_name_ = new ::std::string;
  }
  product_name_->assign(value);
}
inline void Common::set_product_name(const char* value) {
  set_has_product_name();
  if (product_name_ == &::google::protobuf::internal::kEmptyString) {
    product_name_ = new ::std::string;
  }
  product_name_->assign(value);
}
inline void Common::set_product_name(const char* value, size_t size) {
  set_has_product_name();
  if (product_name_ == &::google::protobuf::internal::kEmptyString) {
    product_name_ = new ::std::string;
  }
  product_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Common::mutable_product_name() {
  set_has_product_name();
  if (product_name_ == &::google::protobuf::internal::kEmptyString) {
    product_name_ = new ::std::string;
  }
  return product_name_;
}
inline ::std::string* Common::release_product_name() {
  clear_has_product_name();
  if (product_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_name_;
    product_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string module_name = 2;
inline bool Common::has_module_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Common::set_has_module_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Common::clear_has_module_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Common::clear_module_name() {
  if (module_name_ != &::google::protobuf::internal::kEmptyString) {
    module_name_->clear();
  }
  clear_has_module_name();
}
inline const ::std::string& Common::module_name() const {
  return *module_name_;
}
inline void Common::set_module_name(const ::std::string& value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void Common::set_module_name(const char* value) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(value);
}
inline void Common::set_module_name(const char* value, size_t size) {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  module_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Common::mutable_module_name() {
  set_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    module_name_ = new ::std::string;
  }
  return module_name_;
}
inline ::std::string* Common::release_module_name() {
  clear_has_module_name();
  if (module_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = module_name_;
    module_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string logid = 3;
inline bool Common::has_logid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Common::set_has_logid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Common::clear_has_logid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Common::clear_logid() {
  if (logid_ != &::google::protobuf::internal::kEmptyString) {
    logid_->clear();
  }
  clear_has_logid();
}
inline const ::std::string& Common::logid() const {
  return *logid_;
}
inline void Common::set_logid(const ::std::string& value) {
  set_has_logid();
  if (logid_ == &::google::protobuf::internal::kEmptyString) {
    logid_ = new ::std::string;
  }
  logid_->assign(value);
}
inline void Common::set_logid(const char* value) {
  set_has_logid();
  if (logid_ == &::google::protobuf::internal::kEmptyString) {
    logid_ = new ::std::string;
  }
  logid_->assign(value);
}
inline void Common::set_logid(const char* value, size_t size) {
  set_has_logid();
  if (logid_ == &::google::protobuf::internal::kEmptyString) {
    logid_ = new ::std::string;
  }
  logid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Common::mutable_logid() {
  set_has_logid();
  if (logid_ == &::google::protobuf::internal::kEmptyString) {
    logid_ = new ::std::string;
  }
  return logid_;
}
inline ::std::string* Common::release_logid() {
  clear_has_logid();
  if (logid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logid_;
    logid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .baidu.video.LanguageType language = 4 [default = ZN_CH];
inline bool Common::has_language() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Common::set_has_language() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Common::clear_has_language() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Common::clear_language() {
  language_ = 0;
  clear_has_language();
}
inline baidu::video::LanguageType Common::language() const {
  return static_cast< baidu::video::LanguageType >(language_);
}
inline void Common::set_language(baidu::video::LanguageType value) {
  GOOGLE_DCHECK(baidu::video::LanguageType_IsValid(value));
  set_has_language();
  language_ = value;
}

// optional .baidu.video.CodeType code_type = 5 [default = CODE_TYPE_UNKNOWN];
inline bool Common::has_code_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Common::set_has_code_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Common::clear_has_code_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Common::clear_code_type() {
  code_type_ = 0;
  clear_has_code_type();
}
inline baidu::video::CodeType Common::code_type() const {
  return static_cast< baidu::video::CodeType >(code_type_);
}
inline void Common::set_code_type(baidu::video::CodeType value) {
  GOOGLE_DCHECK(baidu::video::CodeType_IsValid(value));
  set_has_code_type();
  code_type_ = value;
}

// required int64 timestamp = 10;
inline bool Common::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Common::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Common::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Common::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Common::timestamp() const {
  return timestamp_;
}
inline void Common::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// WiseVideoWebplayer

// optional .baidu.video.MetaData metadata = 25;
inline bool WiseVideoWebplayer::has_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WiseVideoWebplayer::set_has_metadata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WiseVideoWebplayer::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WiseVideoWebplayer::clear_metadata() {
  if (metadata_ != NULL) metadata_->::baidu::video::MetaData::Clear();
  clear_has_metadata();
}
inline const ::baidu::video::MetaData& WiseVideoWebplayer::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::baidu::video::MetaData* WiseVideoWebplayer::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::baidu::video::MetaData;
  return metadata_;
}
inline ::baidu::video::MetaData* WiseVideoWebplayer::release_metadata() {
  clear_has_metadata();
  ::baidu::video::MetaData* temp = metadata_;
  metadata_ = NULL;
  return temp;
}

// optional string log_tag = 26;
inline bool WiseVideoWebplayer::has_log_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WiseVideoWebplayer::set_has_log_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WiseVideoWebplayer::clear_has_log_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WiseVideoWebplayer::clear_log_tag() {
  if (log_tag_ != &::google::protobuf::internal::kEmptyString) {
    log_tag_->clear();
  }
  clear_has_log_tag();
}
inline const ::std::string& WiseVideoWebplayer::log_tag() const {
  return *log_tag_;
}
inline void WiseVideoWebplayer::set_log_tag(const ::std::string& value) {
  set_has_log_tag();
  if (log_tag_ == &::google::protobuf::internal::kEmptyString) {
    log_tag_ = new ::std::string;
  }
  log_tag_->assign(value);
}
inline void WiseVideoWebplayer::set_log_tag(const char* value) {
  set_has_log_tag();
  if (log_tag_ == &::google::protobuf::internal::kEmptyString) {
    log_tag_ = new ::std::string;
  }
  log_tag_->assign(value);
}
inline void WiseVideoWebplayer::set_log_tag(const char* value, size_t size) {
  set_has_log_tag();
  if (log_tag_ == &::google::protobuf::internal::kEmptyString) {
    log_tag_ = new ::std::string;
  }
  log_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WiseVideoWebplayer::mutable_log_tag() {
  set_has_log_tag();
  if (log_tag_ == &::google::protobuf::internal::kEmptyString) {
    log_tag_ = new ::std::string;
  }
  return log_tag_;
}
inline ::std::string* WiseVideoWebplayer::release_log_tag() {
  clear_has_log_tag();
  if (log_tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_tag_;
    log_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .baidu.video.Common common = 41;
inline bool WiseVideoWebplayer::has_common() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WiseVideoWebplayer::set_has_common() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WiseVideoWebplayer::clear_has_common() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WiseVideoWebplayer::clear_common() {
  if (common_ != NULL) common_->::baidu::video::Common::Clear();
  clear_has_common();
}
inline const ::baidu::video::Common& WiseVideoWebplayer::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::baidu::video::Common* WiseVideoWebplayer::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::baidu::video::Common;
  return common_;
}
inline ::baidu::video::Common* WiseVideoWebplayer::release_common() {
  clear_has_common();
  ::baidu::video::Common* temp = common_;
  common_ = NULL;
  return temp;
}

// optional string mac_address = 129;
inline bool WiseVideoWebplayer::has_mac_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WiseVideoWebplayer::set_has_mac_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WiseVideoWebplayer::clear_has_mac_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WiseVideoWebplayer::clear_mac_address() {
  if (mac_address_ != &::google::protobuf::internal::kEmptyString) {
    mac_address_->clear();
  }
  clear_has_mac_address();
}
inline const ::std::string& WiseVideoWebplayer::mac_address() const {
  return *mac_address_;
}
inline void WiseVideoWebplayer::set_mac_address(const ::std::string& value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void WiseVideoWebplayer::set_mac_address(const char* value) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(value);
}
inline void WiseVideoWebplayer::set_mac_address(const char* value, size_t size) {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  mac_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WiseVideoWebplayer::mutable_mac_address() {
  set_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    mac_address_ = new ::std::string;
  }
  return mac_address_;
}
inline ::std::string* WiseVideoWebplayer::release_mac_address() {
  clear_has_mac_address();
  if (mac_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_address_;
    mac_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string flag = 130;
inline bool WiseVideoWebplayer::has_flag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WiseVideoWebplayer::set_has_flag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WiseVideoWebplayer::clear_has_flag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WiseVideoWebplayer::clear_flag() {
  if (flag_ != &::google::protobuf::internal::kEmptyString) {
    flag_->clear();
  }
  clear_has_flag();
}
inline const ::std::string& WiseVideoWebplayer::flag() const {
  return *flag_;
}
inline void WiseVideoWebplayer::set_flag(const ::std::string& value) {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  flag_->assign(value);
}
inline void WiseVideoWebplayer::set_flag(const char* value) {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  flag_->assign(value);
}
inline void WiseVideoWebplayer::set_flag(const char* value, size_t size) {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  flag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WiseVideoWebplayer::mutable_flag() {
  set_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    flag_ = new ::std::string;
  }
  return flag_;
}
inline ::std::string* WiseVideoWebplayer::release_flag() {
  clear_has_flag();
  if (flag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flag_;
    flag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string all_data = 131;
inline bool WiseVideoWebplayer::has_all_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WiseVideoWebplayer::set_has_all_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WiseVideoWebplayer::clear_has_all_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WiseVideoWebplayer::clear_all_data() {
  if (all_data_ != &::google::protobuf::internal::kEmptyString) {
    all_data_->clear();
  }
  clear_has_all_data();
}
inline const ::std::string& WiseVideoWebplayer::all_data() const {
  return *all_data_;
}
inline void WiseVideoWebplayer::set_all_data(const ::std::string& value) {
  set_has_all_data();
  if (all_data_ == &::google::protobuf::internal::kEmptyString) {
    all_data_ = new ::std::string;
  }
  all_data_->assign(value);
}
inline void WiseVideoWebplayer::set_all_data(const char* value) {
  set_has_all_data();
  if (all_data_ == &::google::protobuf::internal::kEmptyString) {
    all_data_ = new ::std::string;
  }
  all_data_->assign(value);
}
inline void WiseVideoWebplayer::set_all_data(const char* value, size_t size) {
  set_has_all_data();
  if (all_data_ == &::google::protobuf::internal::kEmptyString) {
    all_data_ = new ::std::string;
  }
  all_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WiseVideoWebplayer::mutable_all_data() {
  set_has_all_data();
  if (all_data_ == &::google::protobuf::internal::kEmptyString) {
    all_data_ = new ::std::string;
  }
  return all_data_;
}
inline ::std::string* WiseVideoWebplayer::release_all_data() {
  clear_has_all_data();
  if (all_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = all_data_;
    all_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string type = 132;
inline bool WiseVideoWebplayer::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WiseVideoWebplayer::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WiseVideoWebplayer::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WiseVideoWebplayer::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& WiseVideoWebplayer::type() const {
  return *type_;
}
inline void WiseVideoWebplayer::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void WiseVideoWebplayer::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void WiseVideoWebplayer::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WiseVideoWebplayer::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* WiseVideoWebplayer::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MetaData

// optional int32 log_module_id = 1 [default = 1526];
inline bool MetaData::has_log_module_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetaData::set_has_log_module_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetaData::clear_has_log_module_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetaData::clear_log_module_id() {
  log_module_id_ = 1526;
  clear_has_log_module_id();
}
inline ::google::protobuf::int32 MetaData::log_module_id() const {
  return log_module_id_;
}
inline void MetaData::set_log_module_id(::google::protobuf::int32 value) {
  set_has_log_module_id();
  log_module_id_ = value;
}

// optional string log_name = 2 [default = "wise_video_webplayer"];
inline bool MetaData::has_log_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaData::set_has_log_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MetaData::clear_has_log_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MetaData::clear_log_name() {
  if (log_name_ != &_default_log_name_) {
    log_name_->assign(_default_log_name_);
  }
  clear_has_log_name();
}
inline const ::std::string& MetaData::log_name() const {
  return *log_name_;
}
inline void MetaData::set_log_name(const ::std::string& value) {
  set_has_log_name();
  if (log_name_ == &_default_log_name_) {
    log_name_ = new ::std::string;
  }
  log_name_->assign(value);
}
inline void MetaData::set_log_name(const char* value) {
  set_has_log_name();
  if (log_name_ == &_default_log_name_) {
    log_name_ = new ::std::string;
  }
  log_name_->assign(value);
}
inline void MetaData::set_log_name(const char* value, size_t size) {
  set_has_log_name();
  if (log_name_ == &_default_log_name_) {
    log_name_ = new ::std::string;
  }
  log_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_log_name() {
  set_has_log_name();
  if (log_name_ == &_default_log_name_) {
    log_name_ = new ::std::string(_default_log_name_);
  }
  return log_name_;
}
inline ::std::string* MetaData::release_log_name() {
  clear_has_log_name();
  if (log_name_ == &_default_log_name_) {
    return NULL;
  } else {
    ::std::string* temp = log_name_;
    log_name_ = const_cast< ::std::string*>(&_default_log_name_);
    return temp;
  }
}

// optional string product_name = 3 [default = "video"];
inline bool MetaData::has_product_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaData::set_has_product_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaData::clear_has_product_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaData::clear_product_name() {
  if (product_name_ != &_default_product_name_) {
    product_name_->assign(_default_product_name_);
  }
  clear_has_product_name();
}
inline const ::std::string& MetaData::product_name() const {
  return *product_name_;
}
inline void MetaData::set_product_name(const ::std::string& value) {
  set_has_product_name();
  if (product_name_ == &_default_product_name_) {
    product_name_ = new ::std::string;
  }
  product_name_->assign(value);
}
inline void MetaData::set_product_name(const char* value) {
  set_has_product_name();
  if (product_name_ == &_default_product_name_) {
    product_name_ = new ::std::string;
  }
  product_name_->assign(value);
}
inline void MetaData::set_product_name(const char* value, size_t size) {
  set_has_product_name();
  if (product_name_ == &_default_product_name_) {
    product_name_ = new ::std::string;
  }
  product_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaData::mutable_product_name() {
  set_has_product_name();
  if (product_name_ == &_default_product_name_) {
    product_name_ = new ::std::string(_default_product_name_);
  }
  return product_name_;
}
inline ::std::string* MetaData::release_product_name() {
  clear_has_product_name();
  if (product_name_ == &_default_product_name_) {
    return NULL;
  } else {
    ::std::string* temp = product_name_;
    product_name_ = const_cast< ::std::string*>(&_default_product_name_);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace video
}  // namespace baidu

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< baidu::video::LanguageType>() {
  return baidu::video::LanguageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< baidu::video::CodeType>() {
  return baidu::video::CodeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_wise_5fvideo_5fwebplayer_2eproto__INCLUDED
